"""
Main CLI implementation for FM-LLM Solver.

Provides unified commands for all system operations.
"""

import sys
from pathlib import Path
from typing import Optional

import click

from fm_llm_solver.core.config import load_config
from fm_llm_solver.core.logging import configure_logging, get_logger


@click.group()
@click.option(
    "--config", "-c", type=click.Path(exists=True), help="Configuration file path"
)
@click.option("--verbose", "-v", is_flag=True, help="Enable verbose logging")
@click.option("--debug", is_flag=True, help="Enable debug logging")
@click.pass_context
def cli(ctx, config: Optional[str], verbose: bool, debug: bool):
    """FM-LLM Solver - Barrier Certificate Generation using Large Language Models."""
    # Ensure context object exists
    ctx.ensure_object(dict)

    # Load configuration
    try:
        ctx.obj["config"] = load_config(config)

        # Configure logging
        log_level = (
            "DEBUG"
            if debug
            else ("INFO" if verbose else ctx.obj["config"].logging.level)
        )
        configure_logging(
            level=log_level,
            console=True,
            structured=ctx.obj["config"].logging.structured,
        )

        ctx.obj["logger"] = get_logger("cli")

    except Exception as e:
        click.echo(f"Error loading configuration: {e}", err=True)
        sys.exit(1)


from .config import config
from .deploy import deploy
from .experiment import experiment

# Import command groups
from .kb import kb
from .train import train
from .web import web

# Register command groups
cli.add_command(kb)
cli.add_command(train)
cli.add_command(web)
cli.add_command(experiment)
cli.add_command(deploy)
cli.add_command(config)


@cli.command()
@click.argument("system_description")
@click.option("--model", default="base", help="Model configuration to use")
@click.option("--rag-k", default=3, help="Number of RAG context chunks")
@click.option("--output", "-o", type=click.Path(), help="Output file for certificate")
@click.option("--verify", is_flag=True, help="Verify the generated certificate")
@click.pass_context
def generate(
    ctx,
    system_description: str,
    model: str,
    rag_k: int,
    output: Optional[str],
    verify: bool,
):
    """Generate a barrier certificate for a given system description."""
    config = ctx.obj["config"]
    logger = ctx.obj["logger"]

    logger.info(f"Generating certificate for system: {system_description[:50]}...")

    try:
        # Initialize services
        from fm_llm_solver.services.certificate_generator import CertificateGenerator
        from fm_llm_solver.services.knowledge_base import KnowledgeBase
        from fm_llm_solver.services.model_provider import ModelProviderFactory

        # Create model provider
        model_provider = ModelProviderFactory.create(
            provider=config.model.provider, config=config.model
        )

        # Create knowledge base if RAG is enabled
        knowledge_base = None
        if config.rag.enabled and rag_k > 0:
            knowledge_base = KnowledgeBase(config)

        # Create generator
        generator = CertificateGenerator(
            config=config, model_provider=model_provider, knowledge_store=knowledge_base
        )

        # Parse system description
        from fm_llm_solver.core.types import SystemDescription, SystemType

        system = SystemDescription(
            dynamics={"x": system_description},  # Simplified for CLI
            initial_set="x <= 1",
            unsafe_set="x >= 10",
            system_type=SystemType.CONTINUOUS,
        )

        # Generate certificate
        result = generator.generate(system)

        if result.success:
            click.echo("\n‚úÖ Certificate generated successfully!")
            click.echo(f"Certificate: {result.certificate.expression}")
            click.echo(f"Confidence: {result.confidence:.2%}")
            click.echo(f"Generation time: {result.generation_time:.2f}s")

            # Save to file if specified
            if output:
                with open(output, "w") as f:
                    f.write("# Generated by FM-LLM Solver\n")
                    f.write(f"# System: {system_description}\n")
                    f.write(f"# Model: {model}\n")
                    f.write(f"# RAG context: {rag_k} chunks\n\n")
                    f.write(f"Certificate: {result.certificate.expression}\n")
                click.echo(f"Certificate saved to: {output}")

            # Verify if requested
            if verify:
                click.echo("\nüîç Verifying certificate...")
                from fm_llm_solver.services.verifier import CertificateVerifier

                verifier = CertificateVerifier(config)
                verification_result = verifier.verify(system, result.certificate)

                if verification_result.valid:
                    click.echo("‚úÖ Certificate verification passed!")
                else:
                    click.echo("‚ùå Certificate verification failed!")
                    for check in verification_result.checks:
                        status = "‚úÖ" if check.passed else "‚ùå"
                        click.echo(f"  {status} {check.check_type}: {check.message}")
        else:
            click.echo(f"‚ùå Certificate generation failed: {result.error}")
            sys.exit(1)

    except Exception as e:
        logger.error(f"Generation failed: {e}")
        click.echo(f"‚ùå Error: {e}", err=True)
        sys.exit(1)


@cli.command()
@click.pass_context
def status(ctx):
    """Show system status and health checks."""
    config = ctx.obj["config"]
    ctx.obj["logger"]

    click.echo("üîç FM-LLM Solver System Status\n")

    # Check configuration
    click.echo("üìã Configuration:")
    click.echo(f"  ‚Ä¢ Config file: {config.paths.kb_output_dir}")
    click.echo(f"  ‚Ä¢ Deployment mode: {config.deployment.mode}")
    click.echo(f"  ‚Ä¢ Model provider: {config.model.provider}")
    click.echo(f"  ‚Ä¢ Model: {config.model.name}")
    click.echo(f"  ‚Ä¢ RAG enabled: {config.rag.enabled}")

    # Check GPU availability
    click.echo("\nüñ•Ô∏è  Hardware:")
    try:
        import torch

        if torch.cuda.is_available():
            gpu_count = torch.cuda.device_count()
            current_gpu = torch.cuda.current_device()
            gpu_name = torch.cuda.get_device_name(current_gpu)
            click.echo(f"  ‚Ä¢ CUDA: ‚úÖ Available ({gpu_count} devices)")
            click.echo(f"  ‚Ä¢ Current GPU: {gpu_name}")

            # Memory info
            memory = torch.cuda.get_device_properties(current_gpu).total_memory
            memory_gb = memory / (1024**3)
            click.echo(f"  ‚Ä¢ GPU Memory: {memory_gb:.1f} GB")
        else:
            click.echo("  ‚Ä¢ CUDA: ‚ùå Not available")
    except ImportError:
        click.echo("  ‚Ä¢ PyTorch: ‚ùå Not installed")

    # Check knowledge base
    click.echo("\nüìö Knowledge Base:")
    kb_dir = Path(config.paths.kb_output_dir)
    if kb_dir.exists():
        kb_files = list(kb_dir.glob("*.faiss"))
        if kb_files:
            click.echo(f"  ‚Ä¢ Status: ‚úÖ Available ({len(kb_files)} indexes)")
            for kb_file in kb_files:
                size_mb = kb_file.stat().st_size / (1024**2)
                click.echo(f"    - {kb_file.name}: {size_mb:.1f} MB")
        else:
            click.echo("  ‚Ä¢ Status: ‚ö†Ô∏è  No indexes found")
    else:
        click.echo("  ‚Ä¢ Status: ‚ùå Directory not found")

    # Check model files
    click.echo("\nü§ñ Models:")
    if config.model.provider == "qwen":
        # Check if model is cached
        model_cache = Path.home() / ".cache" / "huggingface" / "transformers"
        if model_cache.exists():
            model_dirs = [
                d
                for d in model_cache.iterdir()
                if d.is_dir() and "qwen" in d.name.lower()
            ]
            if model_dirs:
                click.echo(f"  ‚Ä¢ Cached models: ‚úÖ Found {len(model_dirs)} Qwen models")
            else:
                click.echo("  ‚Ä¢ Cached models: ‚ö†Ô∏è  No Qwen models cached")
        else:
            click.echo("  ‚Ä¢ Model cache: ‚ùå Not found")

    # Check services
    click.echo("\nüîß Services:")
    try:
        pass

        click.echo("  ‚Ä¢ Certificate Generator: ‚úÖ Available")
    except ImportError as e:
        click.echo(f"  ‚Ä¢ Certificate Generator: ‚ùå {e}")

    try:
        pass

        click.echo("  ‚Ä¢ Verifier: ‚úÖ Available")
    except ImportError as e:
        click.echo(f"  ‚Ä¢ Verifier: ‚ùå {e}")

    click.echo("\n‚úÖ System status check complete!")


@cli.command()
@click.option("--check-deps", is_flag=True, help="Check all dependencies")
@click.option("--install-missing", is_flag=True, help="Install missing dependencies")
@click.pass_context
def setup(ctx, check_deps: bool, install_missing: bool):
    """Set up the FM-LLM Solver environment."""
    config = ctx.obj["config"]
    ctx.obj["logger"]

    click.echo("üîß Setting up FM-LLM Solver environment...\n")

    # Create directories
    click.echo("üìÅ Creating directories...")
    directories = [
        config.paths.kb_output_dir,
        config.paths.ft_data_dir,
        config.paths.output_dir,
        config.paths.log_dir,
        config.paths.temp_dir,
    ]

    for directory in directories:
        Path(directory).mkdir(parents=True, exist_ok=True)
        click.echo(f"  ‚Ä¢ {directory}")

    # Check dependencies if requested
    if check_deps:
        click.echo("\nüì¶ Checking dependencies...")

        required_packages = [
            "torch",
            "transformers",
            "accelerate",
            "bitsandbytes",
            "flask",
            "sqlalchemy",
            "pydantic",
            "omegacon",
            "numpy",
            "scipy",
            "sympy",
            "faiss-cpu",
        ]

        missing_packages = []
        for package in required_packages:
            try:
                __import__(package)
                click.echo(f"  ‚Ä¢ {package}: ‚úÖ")
            except ImportError:
                click.echo(f"  ‚Ä¢ {package}: ‚ùå Missing")
                missing_packages.append(package)

        if missing_packages and install_missing:
            click.echo(
                f"\nüì• Installing missing packages: {', '.join(missing_packages)}"
            )
            import subprocess

            try:
                subprocess.check_call(
                    [sys.executable, "-m", "pip", "install"] + missing_packages
                )
                click.echo("‚úÖ Packages installed successfully!")
            except subprocess.CalledProcessError as e:
                click.echo(f"‚ùå Failed to install packages: {e}")

    # Initialize database
    click.echo("\nüóÑÔ∏è  Initializing database...")
    try:
        from fm_llm_solver.web.app import create_app

        app = create_app()
        with app.app_context():
            from fm_llm_solver.web.models import db

            db.create_all()
        click.echo("  ‚Ä¢ Database initialized ‚úÖ")
    except Exception as e:
        click.echo(f"  ‚Ä¢ Database initialization failed: {e}")

    click.echo("\n‚úÖ Setup complete! Run 'fm-llm status' to check system health.")


if __name__ == "__main__":
    cli()
