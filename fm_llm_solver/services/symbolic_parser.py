"""
Enhanced Symbolic Certificate Parser for FM-LLM-Solver

This module provides advanced symbolic parsing and extraction capabilities
for barrier certificates generated by LLMs, as specified in the GuidanceDoc.
"""

import re
import logging
import ast
import sympy as sp
from typing import Dict, List, Any, Optional, Tuple, Union
from dataclasses import dataclass
import numpy as np


logger = logging.getLogger(__name__)


@dataclass
class CertificateParseResult:
    """Result of certificate parsing."""
    success: bool
    expression: Optional[str] = None
    symbolic_expression: Optional[sp.Expr] = None
    variables: List[str] = None
    complexity_score: int = 0
    format_type: str = "unknown"  # polynomial, trigonometric, rational, etc.
    confidence: float = 0.0
    errors: List[str] = None
    warnings: List[str] = None
    metadata: Dict[str, Any] = None


class SymbolicCertificateParser:
    """Enhanced parser for barrier certificate expressions."""
    
    def __init__(self):
        """Initialize the symbolic parser."""
        self.common_functions = {
            'sin', 'cos', 'tan', 'exp', 'log', 'ln', 'sqrt', 'abs',
            'sinh', 'cosh', 'tanh', 'arcsin', 'arccos', 'arctan',
            'atan2', 'pow', 'power'
        }
        
        self.pattern_cache = {}
        self._compile_patterns()
    
    def _compile_patterns(self):
        """Compile regular expression patterns for efficiency."""
        self.pattern_cache = {
            # Barrier function declarations
            'barrier_function': [
                r'B\s*\(\s*([^)]+)\s*\)\s*=\s*([^.\n;]+)',  # B(x,y) = expression
                r'barrier\s+function\s*:\s*([^.\n;]+)',      # barrier function: expression
                r'barrier\s+certificate\s*:\s*([^.\n;]+)',   # barrier certificate: expression
                r'B\s*=\s*([^.\n;]+)',                       # B = expression
                r'V\s*\(\s*([^)]+)\s*\)\s*=\s*([^.\n;]+)',  # V(x,y) = expression (Lyapunov)
            ],
            
            # Mathematical expressions
            'polynomial': r'(?:[+-]?\d*\.?\d*\*?[a-z_]+\*?\^?\*?\d*\*?)+',
            'variables': r'\b([a-z](?:_?\d*)?)\b',
            'coefficients': r'([+-]?\d*\.?\d+)',
            'operators': r'([+\-*/^()])',
            'functions': r'\b(' + '|'.join(self.common_functions) + r')\s*\(',
            
            # Format detection
            'quadratic_terms': r'[a-z_]+\*?\^?\*?2|[a-z_]+\*\*2|[a-z_]+\^2',
            'cross_terms': r'[a-z_]+\*[a-z_]+',
            'trigonometric': r'\b(?:sin|cos|tan|sinh|cosh|tanh)\s*\(',
            'exponential': r'\b(?:exp|e\^)\s*\(',
            'rational': r'/\s*\(',
            
            # Common artifacts to clean
            'quotes': r'["\']',
            'markdown': r'```[^`]*```|\*\*([^*]+)\*\*|\*([^*]+)\*',
            'latex': r'\$([^$]+)\$|\\[a-zA-Z]+\{[^}]*\}',
        }
    
    def parse_certificate(self, text: str, context: Dict[str, Any] = None) -> CertificateParseResult:
        """
        Parse a barrier certificate from text with enhanced symbolic processing.
        
        Args:
            text: Text containing the barrier certificate
            context: Additional context (system variables, type, etc.)
            
        Returns:
            CertificateParseResult with parsed information
        """
        if not text or not text.strip():
            return CertificateParseResult(
                success=False,
                errors=["Empty or None text provided"]
            )
        
        result = CertificateParseResult(
            success=False,
            variables=[],
            errors=[],
            warnings=[],
            metadata={}
        )
        
        try:
            # Step 1: Clean and preprocess text
            cleaned_text = self._clean_text(text)
            
            # Step 2: Extract candidate expressions
            candidates = self._extract_candidate_expressions(cleaned_text)
            
            if not candidates:
                result.errors.append("No mathematical expressions found")
                return result
            
            # Step 3: Parse and validate each candidate
            best_candidate = None
            best_score = 0
            
            for candidate in candidates:
                parsed = self._parse_single_expression(candidate, context)
                if parsed and parsed.get('score', 0) > best_score:
                    best_candidate = parsed
                    best_score = parsed.get('score', 0)
            
            if not best_candidate:
                result.errors.append("No valid mathematical expressions could be parsed")
                return result
            
            # Step 4: Populate result with best candidate
            result.success = True
            result.expression = best_candidate['expression']
            result.symbolic_expression = best_candidate.get('symbolic')
            result.variables = best_candidate.get('variables', [])
            result.complexity_score = best_candidate.get('complexity', 0)
            result.format_type = best_candidate.get('format_type', 'unknown')
            result.confidence = best_candidate.get('confidence', 0.0)
            result.metadata = best_candidate.get('metadata', {})
            
            # Step 5: Additional validation and warnings
            self._validate_and_warn(result, context)
            
            return result
            
        except Exception as e:
            logger.error(f"Certificate parsing failed: {e}")
            result.errors.append(f"Parsing error: {str(e)}")
            return result
    
    def _clean_text(self, text: str) -> str:
        """Clean text by removing common artifacts and formatting."""
        # Remove markdown formatting
        text = re.sub(self.pattern_cache['markdown'], r'\1\2', text)
        
        # Remove LaTeX formatting
        text = re.sub(self.pattern_cache['latex'], r'\1', text)
        
        # Remove quotes
        text = re.sub(self.pattern_cache['quotes'], '', text)
        
        # Normalize whitespace
        text = re.sub(r'\s+', ' ', text)
        
        # Replace common notation variations
        replacements = {
            '**': '^',  # Python power to standard notation
            'x_1': 'x1', 'x_2': 'x2',  # Subscript normalization
            'y_1': 'y1', 'y_2': 'y2',
            '\\cdot': '*',  # LaTeX multiplication
            '\\times': '*',
            '\\frac': '/',  # Simplified fraction handling
        }
        
        for old, new in replacements.items():
            text = text.replace(old, new)
        
        return text.strip()
    
    def _extract_candidate_expressions(self, text: str) -> List[str]:
        """Extract potential barrier certificate expressions from text."""
        candidates = []
        
        # Method 1: Look for explicit barrier function declarations
        for pattern in self.pattern_cache['barrier_function']:
            matches = re.finditer(pattern, text, re.IGNORECASE | re.MULTILINE)
            for match in matches:
                if len(match.groups()) == 2:
                    # Pattern with variables: B(x,y) = expression
                    variables_part = match.group(1)
                    expression_part = match.group(2)
                    candidates.append({
                        'expression': expression_part.strip(),
                        'variables': self._extract_variables_from_declaration(variables_part),
                        'source': 'explicit_declaration',
                        'confidence_bonus': 0.3
                    })
                else:
                    # Pattern without variables: B = expression
                    expression_part = match.group(1)
                    candidates.append({
                        'expression': expression_part.strip(),
                        'variables': None,
                        'source': 'simple_declaration',
                        'confidence_bonus': 0.2
                    })
        
        # Method 2: Look for mathematical expressions
        lines = text.split('\n')
        for line in lines:
            line = line.strip()
            if self._looks_like_mathematical_expression(line):
                candidates.append({
                    'expression': line,
                    'variables': None,
                    'source': 'mathematical_line',
                    'confidence_bonus': 0.1
                })
        
        # Method 3: Extract expressions from mathematical contexts
        math_contexts = [
            r'(?:barrier|lyapunov|function|certificate)\s*:?\s*([^.\n]+)',
            r'(?:B|V)\s*\([^)]*\)\s*=\s*([^.\n]+)',
            r'(?:solution|answer|result)\s*:?\s*([^.\n]+)',
        ]
        
        for pattern in math_contexts:
            matches = re.finditer(pattern, text, re.IGNORECASE)
            for match in matches:
                expression = match.group(1).strip()
                if self._looks_like_mathematical_expression(expression):
                    candidates.append({
                        'expression': expression,
                        'variables': None,
                        'source': 'contextual_extraction',
                        'confidence_bonus': 0.15
                    })
        
        # Remove duplicates and return clean expressions
        unique_expressions = []
        seen = set()
        
        for candidate in candidates:
            expr = candidate['expression']
            if expr not in seen and len(expr) > 3:
                seen.add(expr)
                unique_expressions.append(candidate)
        
        return unique_expressions
    
    def _extract_variables_from_declaration(self, variables_part: str) -> List[str]:
        """Extract variable names from function declaration like B(x,y)."""
        # Clean up the variables part
        variables_part = re.sub(r'[^a-zA-Z0-9_,\s]', '', variables_part)
        
        # Split by comma and clean
        variables = []
        for var in variables_part.split(','):
            var = var.strip()
            if var and re.match(r'^[a-zA-Z][a-zA-Z0-9_]*$', var):
                variables.append(var)
        
        return variables
    
    def _looks_like_mathematical_expression(self, text: str) -> bool:
        """Check if text looks like a mathematical expression."""
        if len(text) < 3:
            return False
        
        # Must contain variables
        if not re.search(r'\b[a-z](?:_?\d*)?\b', text, re.IGNORECASE):
            return False
        
        # Must contain mathematical operators or functions
        if not re.search(r'[+\-*/^()=]|' + self.pattern_cache['functions'], text):
            return False
        
        # Shouldn't be mostly text
        math_chars = len(re.findall(r'[a-zA-Z0-9+\-*/^()=.\s]', text))
        total_chars = len(text)
        
        if math_chars / total_chars < 0.7:
            return False
        
        return True
    
    def _parse_single_expression(self, candidate: Dict[str, Any], context: Dict[str, Any] = None) -> Optional[Dict[str, Any]]:
        """Parse a single candidate expression."""
        expression = candidate['expression']
        
        try:
            # Step 1: Basic cleaning and normalization
            normalized_expr = self._normalize_expression(expression)
            
            # Step 2: Extract variables
            variables = candidate.get('variables') or self._extract_variables(normalized_expr)
            
            # Step 3: Attempt symbolic parsing
            symbolic_expr = None
            try:
                # Create sympy symbols for variables
                if variables:
                    symbol_dict = {var: sp.Symbol(var, real=True) for var in variables}
                    # Replace variables in expression for sympy
                    sympy_expr = normalized_expr
                    for var in variables:
                        sympy_expr = sympy_expr.replace(var, f'Symbol("{var}")')
                    
                    # Parse with sympy
                    symbolic_expr = sp.sympify(normalized_expr, locals=symbol_dict)
                    
            except Exception as e:
                logger.debug(f"Sympy parsing failed for '{normalized_expr}': {e}")
                symbolic_expr = None
            
            # Step 4: Analyze expression characteristics
            format_type = self._detect_format_type(normalized_expr)
            complexity = self._calculate_complexity(normalized_expr)
            confidence = self._calculate_confidence(candidate, normalized_expr, symbolic_expr, context)
            
            # Step 5: Calculate overall score
            score = confidence * 100 + complexity * 0.1
            if symbolic_expr is not None:
                score += 20  # Bonus for successful symbolic parsing
            
            return {
                'expression': normalized_expr,
                'symbolic': symbolic_expr,
                'variables': variables,
                'format_type': format_type,
                'complexity': complexity,
                'confidence': confidence,
                'score': score,
                'source': candidate.get('source', 'unknown'),
                'metadata': {
                    'original_expression': expression,
                    'normalization_applied': expression != normalized_expr,
                    'symbolic_parsing_success': symbolic_expr is not None,
                }
            }
            
        except Exception as e:
            logger.debug(f"Failed to parse expression '{expression}': {e}")
            return None
    
    def _normalize_expression(self, expression: str) -> str:
        """Normalize mathematical expression to standard form."""
        # Remove extra whitespace
        expr = re.sub(r'\s+', ' ', expression).strip()
        
        # Standardize power notation
        expr = re.sub(r'\*\*(\d+)', r'^\\1', expr)  # ** to ^
        expr = re.sub(r'\^(\d+)', r'^\\1', expr)    # Ensure proper format
        
        # Standardize multiplication
        expr = re.sub(r'(\d)([a-zA-Z])', r'\\1*\\2', expr)  # 2x -> 2*x
        expr = re.sub(r'([a-zA-Z])(\d)', r'\\1*\\2', expr)  # x2 -> x*2
        expr = re.sub(r'([a-zA-Z])([a-zA-Z])', r'\\1*\\2', expr)  # xy -> x*y
        
        # Handle parentheses multiplication
        expr = re.sub(r'(\))(\()', r'\\1*\\2', expr)  # )( -> )*(
        expr = re.sub(r'(\d)(\()', r'\\1*\\2', expr)  # 2( -> 2*(
        expr = re.sub(r'(\))([a-zA-Z])', r'\\1*\\2', expr)  # )x -> )*x
        
        return expr
    
    def _extract_variables(self, expression: str) -> List[str]:
        """Extract variable names from expression."""
        # Find all potential variables (single letters or letter+digit)
        variables = set()
        
        # Pattern for variables: single letters or letter followed by digits/underscores
        pattern = r'\b([a-zA-Z])(?:[_\d]*)\b'
        matches = re.findall(pattern, expression)
        
        for match in matches:
            # Filter out function names and keywords
            if match.lower() not in self.common_functions and match.lower() not in ['e', 'pi']:
                variables.add(match.lower())
        
        return sorted(list(variables))
    
    def _detect_format_type(self, expression: str) -> str:
        """Detect the mathematical format type of the expression."""
        expr_lower = expression.lower()
        
        # Check for trigonometric functions
        if re.search(self.pattern_cache['trigonometric'], expr_lower):
            return 'trigonometric'
        
        # Check for exponential functions
        if re.search(self.pattern_cache['exponential'], expr_lower):
            return 'exponential'
        
        # Check for rational functions (fractions)
        if '/' in expression and re.search(self.pattern_cache['rational'], expression):
            return 'rational'
        
        # Check for polynomial characteristics
        if re.search(self.pattern_cache['quadratic_terms'], expression):
            if re.search(self.pattern_cache['cross_terms'], expression):
                return 'polynomial_multivariate'
            else:
                return 'polynomial_quadratic'
        
        # Check for linear terms
        if re.search(r'\b[a-z]+\b', expr_lower) and not re.search(r'[\^*]{2}', expression):
            return 'linear'
        
        return 'unknown'
    
    def _calculate_complexity(self, expression: str) -> int:
        """Calculate complexity score of the expression."""
        complexity = 0
        
        # Base complexity from length
        complexity += len(expression) // 10
        
        # Operators complexity
        complexity += len(re.findall(r'[+\-*/^]', expression))
        
        # Functions complexity
        complexity += len(re.findall(self.pattern_cache['functions'], expression)) * 2
        
        # Parentheses complexity
        complexity += len(re.findall(r'[()]', expression))
        
        # Polynomial degree complexity
        degree_matches = re.findall(r'\^(\d+)', expression)
        if degree_matches:
            max_degree = max(int(d) for d in degree_matches)
            complexity += max_degree * 2
        
        return min(complexity, 100)  # Cap at 100
    
    def _calculate_confidence(self, candidate: Dict[str, Any], expression: str, 
                             symbolic_expr: Optional[sp.Expr], context: Dict[str, Any] = None) -> float:
        """Calculate confidence score for the parsed expression."""
        confidence = 0.4  # Base confidence
        
        # Source confidence bonus
        confidence += candidate.get('confidence_bonus', 0)
        
        # Symbolic parsing success bonus
        if symbolic_expr is not None:
            confidence += 0.2
        
        # Mathematical validity indicators
        if self._has_valid_mathematical_structure(expression):
            confidence += 0.1
        
        # Variable consistency
        if context and 'expected_variables' in context:
            extracted_vars = set(self._extract_variables(expression))
            expected_vars = set(context['expected_variables'])
            if extracted_vars.issubset(expected_vars) or expected_vars.issubset(extracted_vars):
                confidence += 0.1
        
        # Format appropriateness for barrier certificates
        format_type = self._detect_format_type(expression)
        if format_type in ['polynomial_quadratic', 'polynomial_multivariate']:
            confidence += 0.1  # Quadratic forms are common for barrier certificates
        
        return min(confidence, 1.0)
    
    def _has_valid_mathematical_structure(self, expression: str) -> bool:
        """Check if expression has valid mathematical structure."""
        # Balanced parentheses
        if expression.count('(') != expression.count(')'):
            return False
        
        # No consecutive operators
        if re.search(r'[+\-*/^]{2,}', expression):
            return False
        
        # Must contain variables
        if not re.search(r'\b[a-z]\b', expression, re.IGNORECASE):
            return False
        
        return True
    
    def _validate_and_warn(self, result: CertificateParseResult, context: Dict[str, Any] = None):
        """Add validation warnings to the result."""
        if not result.success:
            return
        
        # Check for common issues
        if result.complexity_score > 50:
            result.warnings.append("Expression is quite complex, may be difficult to verify")
        
        if result.format_type == 'unknown':
            result.warnings.append("Could not determine mathematical format type")
        
        if len(result.variables) > 10:
            result.warnings.append("Expression has many variables, may be overly complex")
        
        if result.confidence < 0.6:
            result.warnings.append("Low confidence in expression extraction")
        
        # Context-specific validation
        if context:
            if 'system_type' in context and context['system_type'] == 'discrete':
                if 'continuous' in result.expression.lower():
                    result.warnings.append("Expression may not be suitable for discrete-time systems")
    
    def validate_barrier_certificate(self, expression: str, variables: List[str] = None) -> Dict[str, Any]:
        """
        Validate if expression is suitable as a barrier certificate.
        
        Returns validation results with specific barrier certificate criteria.
        """
        try:
            # Parse the expression first
            parse_result = self.parse_certificate(expression)
            
            if not parse_result.success:
                return {
                    'valid': False,
                    'errors': parse_result.errors,
                    'warnings': parse_result.warnings
                }
            
            validation = {
                'valid': True,
                'errors': [],
                'warnings': [],
                'properties': {}
            }
            
            # Check if it's a valid barrier certificate candidate
            symbolic_expr = parse_result.symbolic_expression
            expr_variables = parse_result.variables
            
            if symbolic_expr and expr_variables:
                # Create sympy symbols
                symbols = [sp.Symbol(var, real=True) for var in expr_variables]
                
                # Check properties that are good for barrier certificates
                
                # 1. Continuity (most expressions are continuous)
                validation['properties']['continuous'] = True
                
                # 2. Check if it's polynomial (easier to verify)
                is_polynomial = sp.Poly(symbolic_expr, *symbols, domain='RR').is_polynomial
                validation['properties']['polynomial'] = is_polynomial
                
                if is_polynomial:
                    validation['properties']['degree'] = sp.degree(symbolic_expr)
                
                # 3. Check for positive definiteness candidates (quadratic forms)
                if parse_result.format_type in ['polynomial_quadratic', 'polynomial_multivariate']:
                    validation['properties']['quadratic_form'] = True
                    validation['warnings'].append("Consider checking positive definiteness for barrier properties")
                
                # 4. Check for smoothness (differentiability)
                try:
                    # Try to compute gradients
                    gradients = [sp.diff(symbolic_expr, var) for var in symbols]
                    validation['properties']['differentiable'] = True
                    validation['properties']['gradient_computed'] = True
                except:
                    validation['properties']['differentiable'] = False
                    validation['warnings'].append("Could not verify differentiability")
            
            return validation
            
        except Exception as e:
            logger.error(f"Barrier certificate validation failed: {e}")
            return {
                'valid': False,
                'errors': [f"Validation error: {str(e)}"],
                'warnings': []
            } 